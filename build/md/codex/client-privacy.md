# How we protect your privacy in OpenCPEs

An example first: when someone passes the CCSK exam from the CSA a verification code is created. This code is a 12 digit random number (“123456789123”), which combined with your email address this allows someone to validate your CCSK exam. If you were to create and publicly publish a SHA512 hash with your email address and CCSK validation code it would be trivial for an attacker to simple brute force search the for your email address plus every valid CCSK validation code using the public hash value. The reason that brute forcing these hash values is so easy is that many forms of data (such as your birthday or Tax ID # like SSN/SIN) are a simple string of numbers and there are not very many valid inputs (a few billion typically). An attacker can simply walk through every possible value, the chances of two of these values having the same hash are infinitesimal so once they find a valid one they can be reasonably certain that it is correct.

In order to protect the client data from simple brute force attacks against the hash value the client provides we have the client system create a random value (a secret “nonce”) that is 1024 bits in length, and then take the 512 bit hash of the original data plus the secret nonce.

Now we have a situation where we have a guessable number (“123456789123”) but a much larger random value added to it, which means that there will be a large number of secret nonce + valid 12 digit number that result in the hash value the client generated. In fact there are so many valid combinations of secret nonce + 12 digit number that each 12 digit number will have thousands of valid hash results, meaning an attacker will be overwhelmed with results and not know which one is valid.

Thus a client can, with confidence, create a hash value that cannot be brute forced reliably to expose the original data.
